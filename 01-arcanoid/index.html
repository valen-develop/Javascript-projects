<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arcanoid</title>
    <style>
      body {
        background-color: rgb(22, 22, 22);
      }
      #canvas {
        border: 2px solid white;
        border-bottom: transparent;
        margin: 0 auto;
        display: block;
        background-image: url('./assets/bkg.png');
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <img hidden src="./assets/bricks.png" alt="" id="bricks" />
    <img hidden src="./assets/sprite.png" alt="" id="sprite" />
    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 448;
      canvas.height = 400;

      const $sprite = document.getElementById('sprite');
      const $bricks = document.getElementById('bricks');

      // VARIABLES DE LADRILLOS
      const brickRowCount = 6;
      const brickColumnCount = 13;
      const brickWidth = 32;
      const brickHeight = 16;
      const brickPadding = 0;
      const brickOffsetTop = 40;
      const brickOffsetLeft = 20;
      const brikcs = [];

      const BRICK_STATUS = {
        ACTIVE: 1,
        DESTROYED: 0,
      };

      for (let c = 0; c < brickColumnCount; c++) {
        brikcs[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
          const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;

          // Asignar un color aleatorio a cada ladrillo
          const randomColor = Math.floor(Math.random() * 8);

          brikcs[c][r] = {
            x: brickX,
            y: brickY,
            color: randomColor,
            status: BRICK_STATUS.ACTIVE,
          };
        }
      }

      // BALL
      const ballRadius = 3;
      let x = canvas.width / 2;
      let y = canvas.height - 20;

      // velocidad de la pelota
      let dx = 4;
      let dy = -4;

      const paddleWidth = 50;
      const paddleHeight = 10;
      let paddleX = (canvas.width - paddleWidth) / 2;
      let paddleY = canvas.height - paddleHeight - 10;

      let rigthPress = false;
      let leftPress = false;
      const PADDLE_SENSITIVITY = 7;

      function drawBall() {
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.closePath();
      }

      function initEvents() {
        document.addEventListener('keydown', keyDownHandle);
        document.addEventListener('keyup', keyUpHandle);

        function keyDownHandle(e) {
          const { key } = e;
          if (key === 'Right' || key === 'ArrowRight') {
            rigthPress = true;
          } else if (key === 'Left' || key === 'ArrowLeft') {
            leftPress = true;
          }
        }

        function keyUpHandle(e) {
          const { key } = e;
          if (key === 'Right' || key === 'ArrowRight') {
            rigthPress = false;
          } else if (key === 'Left' || key === 'ArrowLeft') {
            leftPress = false;
          }
        }
      }

      function drawPaddle() {
        ctx.drawImage(
          $sprite,
          29,
          174,
          paddleWidth,
          paddleHeight,
          paddleX,
          paddleY,
          paddleWidth,
          paddleHeight
        );
      }

      function drawBricks() {
        for (let c = 0; c < brickColumnCount; c++) {
          for (let r = 0; r < brickRowCount; r++) {
            const currentBrick = brikcs[c][r];
            if (currentBrick.status === BRICK_STATUS.DESTROYED) continue;
            const clipX = currentBrick.color * 32;
            ctx.drawImage(
              $bricks,
              clipX,
              0,
              31,
              14,
              currentBrick.x,
              currentBrick.y,
              brickWidth,
              brickHeight
            );
          }
        }
      }

      function detectColision() {
        for (let c = 0; c < brickColumnCount; c++) {
          for (let r = 0; r < brickRowCount; r++) {
            const currentBrick = brikcs[c][r];
            if (currentBrick.status === BRICK_STATUS.DESTROYED) continue;

            const isBallSameXASBrick =
              x > currentBrick.x && x < currentBrick.x + brickWidth;

            const isBallTouchingBrick =
              y > currentBrick.y && y < currentBrick.y + brickHeight;
            if (isBallSameXASBrick && isBallTouchingBrick) {
              dy = -dy;
              currentBrick.status = BRICK_STATUS.DESTROYED;
            }
          }
        }
      }

      function ballMovement() {
        // Rebotar las pelotas en los laterales
        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
          dx = -dx;
        }

        // Rebotar en la parte de arriba
        if (y + dy < ballRadius) {
          dy = -dy;
        }

        const isBallSameXAsPaddle = x > paddleX && x < paddleX + paddleWidth;
        const isBallTouchingPaddle = y + dy > paddleY;

        if (isBallSameXAsPaddle && isBallTouchingPaddle) {
          dy = -dy;
        } else if (y + dy > canvas.height - ballRadius) {
          document.location.reload();
        }

        x += dx;
        y += dy;
      }

      function paddleMovement() {
        if (rigthPress && paddleX < canvas.width - paddleWidth) {
          paddleX += PADDLE_SENSITIVITY;
        } else if (leftPress && paddleX > 0) {
          paddleX -= PADDLE_SENSITIVITY;
        }
      }

      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      // Funcion  de repintado
      function draw() {
        console.log({ rigthPress, leftPress });
        clearCanvas();
        drawBall();
        drawPaddle();
        drawBricks();

        detectColision();
        ballMovement();
        paddleMovement();

        // Se ejecuta 60 veces por segundo dependiendo del monitor
        window.requestAnimationFrame(draw);
      }

      draw();
      initEvents();
    </script>
  </body>
</html>
